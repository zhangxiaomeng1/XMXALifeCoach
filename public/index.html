<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 人生教练</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="chat-container">
        <div class="messages" id="messages"></div>
        <div class="input-area">
            <input type="text" id="userInput" placeholder="请分享您今天的成长困惑...">
            <button onclick="sendMessage()">发送</button>
        </div>
    </div>

    <script>
        let conversationHistory = [
            { role: "system", content: "你是一位专业的人生教练，需要通过对话帮助用户成长。使用亲切的中文，每次回答不超过200字。" }
        ];

        // 在 appendMessage 函数前添加防错处理
        function safeAppendMessage(role, content) {
            const messagesDiv = document.getElementById('messages');
            if (!messagesDiv) {
                console.error('消息容器未找到');
                return null;
            }
            return appendMessage(role, content);
        }

        async function sendMessage() {
            const userInput = document.getElementById('userInput');
            const message = userInput.value.trim();
            if (!message) return;

            // 添加用户消息
            appendMessage('user', message);
            conversationHistory.push({ role: "user", content: message });
            userInput.value = '';

            // 显示加载状态
            // 修改消息添加方式
            const loadingElem = safeAppendMessage('assistant', '思考中...');
            if (!loadingElem) return;

            try {
                // 添加超时处理
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 60000);

                const response = await fetch('/api/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ messages: conversationHistory }),
                    signal: controller.signal
                });
                clearTimeout(timeoutId);

                // 强化流式处理
                const reader = response.body.getReader();
                let fullResponse = '';
                loadingElem.textContent = '';
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    const chunk = new TextDecoder().decode(value);
                    
                    // 修改后的数据块处理逻辑
                    chunk.split('\n').forEach(line => {
                        const trimmedLine = line.trim();
                        if (!trimmedLine || trimmedLine === 'data: [DONE]') return;
                        
                        try {
                            // 移除 "data: " 前缀
                            const jsonString = trimmedLine.replace(/^data: /, '');
                            const data = JSON.parse(jsonString);
                            // 添加空值检查
                            const content = data.choices[0]?.delta?.content || '';
                            fullResponse += content;
                            // 实时更新内容
                            loadingElem.textContent = fullResponse; 
                        } catch(e) {
                            console.warn('解析错误:', e);
                            console.log('原始数据:', line);
                        }
                    });
                }
                
                conversationHistory.push({ role: "assistant", content: fullResponse });
                
            } catch (error) {
                // 细化错误处理
                loadingElem.textContent = error.name === 'AbortError' ? 
                    '请求超时，请稍后再试' : 
                    '服务暂时不可用，请检查网络连接';
            }
        }

        function appendMessage(role, content) {
            const messagesDiv = document.getElementById('messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${role}`;
            messageDiv.textContent = content;
            messagesDiv.appendChild(messageDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
            return messageDiv;
        }
    </script>
</body>
</html>
